    var crypto = require('crypto')
    , shasum = crypto.createHash('sha1');
    var DBM = require('./db');

    var Mongood = function (entity, ns) {
        if (typeof(ns) === 'undefined') ns = 'core';
        this.ns = ns;
        this.entity = entity;
        this.results = [];
        this.wheres = [];
        this.fns = {};
        this.db = 'db_' + entity;
        this.lastInsertId = null;

        this.create = function () {
            var obj = {};
            return this.closures(obj);
        };

        this.closures = function (obj) {
            obj._db = this;
            obj.fn = {
                save: function () {
                    return obj._db.save(obj);
                },
                delete: function() {
                    return obj._db.drop(obj.id);
                }
            };
            if (this.fns.length > 0) {
                for (var key in this.fns) {
                    var cb = this.fns[key];
                    obj[key] = cb;
                }
            }
            return obj;
        };

        this.addFn = function (name, cb) {
            if (typeof(cb) == 'function') {
                this.fns[name] = cb;
            }
            return this;
        };

        this.cleanObj = function (obj) {
            var _db = this.ake(obj, '_db', null);
            var fn = this.ake(obj, 'fn', null);
            if (null !== _db) {
                delete obj._db;
            }
            if (null !== fn) {
                delete obj.fn;
            }
            return obj;
        };

        this.save = function (data) {
            if (typeof(data) === 'object') {
                data = this.cleanObj(data);
            }
            var id = this.ake(data, 'id', null);
            if (null !== id) {
                return this.edit(id, data);
            } else {
                return this.add(data);
            }
        };

        this.add = function (data) {
            this.lock('add');
            var key = this.hash(data);
            var exists = this.driver().get(key);
            if (null === exists) {
                var id = this.driver().incr(this.entity + '_count');
                data.id = id;
                this.driver().set(this.db + '::' + id, data);
                this.all();
                this.driver().set(key, id);
                this.unlock('add');
                this.lastInsertId = id;
                return this.closures(data);
            } else {
                this.unlock('add');
                this.lastInsertId = exists;
                return this.find(exists);
            }
        };

        this.edit = function (id, data)  {
            this.drop(id);
            this.lock('edit');
            this.driver().set(this.db + '::' + id, data);
            this.all();
            this.unlock('edit');
            return this.closures(data);
        };

        this.drop = function (id) {
            var row = this.find(id);
            delete row.id;
            var key = this.hash(row);
            this.lock('delete');
            this.driver().del(this.db + '::' + id);
            this.driver().del(key);
            this.unlock('delete');
            return this;
        };

        this.all = function () {
            var rows = this.driver().keys(this.db + '::%%');
            var collection = [];
            if (rows.length > 0) {
                for (var index in rows) {
                    var row = rows[index];
                    var data = this.driver().get(row);
                    collection.push(this.closures(data));
                }
            }
            return collection;
        };

        this.find = function (id) {
            var row = this.driver().get(this.db + '::' + id);
            return null !== row ? this.closures(row) : this.create();
        };

        this.fetch = function () {
            this.results = this.all();
            return this;
        };

        this.groupBy = function(field) {
            var groupBys = [];
            var ever = [];

            if (this.results.length == 0) {
                return this;
            }

            for (index in this.results) {
                var row = this.results[index];
                var value = this.ake(row, field, null);
                if (!this.inArray(value, ever)) {
                    groupBys[index] = row;
                    ever.push(value);
                }
            }

            this.results = groupBys;
            this.sort(field);

            return this;
        };

        this.sum = function(field) {
            var sum = 0;

            if (this.results.length > 0) {
                for (var index in this.results) {
                    var row = this.results[index];
                    var val = this.ake(row, field, 0);
                    val = parseInt(val);
                    sum += val;
                }
            }
            this.reset();
            return sum;
        };

        this.avg = function (field) {
            return this.results.length < 1 ? 0 : this.sum(field) / this.results.length;
        };

        this.min = function (field) {
            var min = 0;
            if (this.results.length > 0) {
                var first = true;
                for (var index in this.results) {
                    var row = this.results[index];
                    var val = this.ake(row, field, 0);
                    val = parseInt(val);
                    if (true === first) {
                        min = val;
                    } else {
                        min = val < min ? val : min;
                    }
                    first = false;
                }
            }
            this.reset();
            return min;
        };

        this.max = function (field) {
            var max = 0;
            if (this.results.length > 0) {
                var first = true;
                for (var index in this.results) {
                    var row = this.results[index];
                    var val = this.ake(row, field, 0);
                    val = parseInt(val);
                    if (true === first) {
                        max = val;
                    } else {
                        max = val > max ? val : max;
                    }
                    first = false;
                }
            }
            this.reset();
            return max;
        }

        this.getLastId = function () {
            return this.lastInsertId;
        };

        this.countAll = function () {
            var collection = this.all();
            return collection.length;
        };

        this.count = function () {
            return this.results.length;
        };

        this.limit = function (limit, offset) {
            if (typeof(offset) === 'undefined') offset = 0;
            limit = parseInt(limit);
            offset = parseInt(offset);
            offset = this.results.length < offset ? this.results.length : offset;
            this.results = this.results.slice(offset, offset + limit);
            return this;
        };

        this.exec = function() {
            var collection = [];
            if (this.results.length > 0) {
                for (var index in this.results) {
                    collection.push(this.closures(this.results[index]));
                }
            }
            this.reset();
            return collection;
        };

        this.sort = function (field, direction) {
            if (typeof(direction) === 'undefined') direction = 'ASC';
            if (this.results.length > 0) {
                this.results.sort(
                    function (a, b) {
                        if ('ASC' == direction) {
                            return a[field] > b[field];
                        } else {
                            return a[field] < b[field];
                        }
                    }
                );
            }
            return this;
        };

        this.intersect = function(a, b) {
            var results = new Array();
            if (a.length < 1 || b.length < 1) {
                return results;
            }
            var aIds = new Array();
            for (var key in a) {
                var row = a[key];
                var id = row.id;
                aIds[id] = true;
            }

            for (var key in b) {
                var row = b[key];
                var id = row.id;
                var exists = this.ake(aIds, id, false);
                if (exists) {
                    results.push(row);
                }
            }
            return results;
        };

        this.merge = function (a, b) {
            if (a.length == 0) {
                return b;
            }
            if (b.length == 0) {
                return a;
            }
            var results = new Array();
            var aIds = new Array();

            for (var key in a) {
                var row = a[key];
                var id = row.id;
                aIds[id] = true;
                results.push(row);
            }

            for (var key in b) {
                var row = b[key];
                var id = row.id;
                var exists = this.ake(aIds, id, false);
                if (!exists) {
                    results.push(row);
                }
            }
            return results;
        };

        this.query = function ($sql) {
            if (sql.match(' && ')) {
                var segs = sql.split(' && ');
                for (var key in segs) {
                    var seg = segs[key];
                    this.where(seg);
                    sql = sql.split(seg + ' && ').join();
                }
            }
            if (sql.match(' || ')) {
                var segs = sql.split(' || ');
                for (var key in segs) {
                    var seg = segs[key];
                    this.where(seg, 'OR');
                    sql = sql.split(seg + ' || ').join();
                }
            }
            if (sql.length > 0) {
                this.where(sql);
            }
            return this;
        };

        this.where = function (condition, op) {
            if (typeof(op) === 'undefined') op = 'AND';
            var res = this.search(condition);
            if (this.wheres.length == 0) {
                this.results = res;
            } else {
                if (op == 'AND') {
                    this.results = this.intersect(this.results, res);
                } else {
                    this.results = this.merge(this.results, res);
                }
            }
            this.wheres.push(condition);
            return this;
        };

        this.search = function(condition) {
            if (typeof(condition) === 'undefined') condition = '';
            var datas = this.all();
            if (condition.length == 0) return datas;
            if (datas.length == 0) return datas;

            condition  = condition.split('NOT LIKE').join('NOTLIKE');
            condition  = condition.split('NOT IN').join('NOTIN');

            var tab     = condition.split(' ');
            var field   = tab[0];
            var op      = tab[1];
            var value   = tab[2];

            var collection = [];

            for (var index in datas) {
                var row = datas[index];
                var val = this.ake(row, field, null);
                if (null !== val) {
                    var check = this.compare(val, op, value);
                } else {
                    var check = ('null' == value) ? true : false;
                }
                if (true === check) {
                    collection.push(row);
                }
            }
            this.results = collection;
            return collection;
        };

        this.compare = function (comp, op, value) {
            if (typeof(comp) === 'string') comp = comp.toLowerCase();
            if (typeof(value) === 'string') value = value.toLowerCase();

            if (typeof(comp) === 'number') {
                value = parseInt(value);
            }

            var res = false;
            if (null !== comp) {
                switch (op) {
                    case '=':
                        res = this.hashStr(comp) == this.hashStr(value);
                        break;
                    case '>=':
                        res = comp >= value;
                        break;
                    case '>':
                        res = comp > value;
                        break;
                    case '<':
                        res = comp < value;
                        break;
                    case '<=':
                        res = comp <= value;
                        break;
                    case '<>':
                    case '!=':
                        res = this.hashStr(comp) != this.hashStr(value);
                        break;
                    case 'LIKE':
                        value = value.split("'").join('');
                        value = value.split("%").join('');
                        if (comp.match(value)) {
                            res = true;
                        }
                        break;
                    case 'NOTLIKE':
                        value = value.split("'").join('');
                        value = value.split("%").join('');
                        if (!comp.match(value)) {
                            res = true;
                        }
                        break;
                    case 'LIKE START':
                        value = value.split("'").join('');
                        value = value.split("%").join('');
                        res = (substr(comp, 0, value.length) === value);
                        break;
                    case 'LIKE END':
                        value = value.split("'").join('');
                        value = value.split("%").join('');
                        if (comp.length == 0) {
                            res = true;
                        } else {
                            res = (substr(comp, -value.length) === value);
                        }
                        break;
                    case 'IN':
                        value = value.split("(").join('');
                        value = value.split(")").join('');
                        var tabValues = value.split(',');
                        res = this.inArray(comp, tabValues);
                        break;
                    case 'NOTIN':
                        value = value.split("(").join('');
                        value = value.split(")").join('');
                        var tabValues = value.split(',');
                        res = !this.inArray(comp, tabValues);
                        break;
                }
            }
            return res;
        };

        this.findBy = function (field, value, one) {
            if (typeof(one) === 'undefined') one = false;
            var res = this.search(field + ' = '+ value);
            if (true === one) {
                return res.length > 0 ? res[0] : this.create();
            }
            return this.exec();
        };

        this.findOneBy = function(field, value) {
            return this.findBy(field, value, true);
        };

        this.first = function () {
            var res = this.results;
            this.reset();
            return res.length > 0 ? res[0] : this.create();
        };

        this.last = function () {
            var res = this.results;
            this.reset();
            return res.length > 0 ? res[res.length - 1] : this.create();
        };

        this.inArray = function (needle, haystack) {
            var length = haystack.length;
            for(var i = 0; i < length; i++) {
                if(haystack[i] == needle) return true;
            }
            return false;
        };

        this.reset = function () {
            this.results = [];
            this.wheres = [];
        };

        this.waitUnlock = function (action) {
            console.log("waitUnlock " + action);
            var wait = this.driver().isLocked().length > 0 ? true : false;
            if (true === wait) {
                return false;
            }
            return true;
        };

        this.lock = function (action) {
            console.log("lock " + action);
            var can = this.waitUnlock(action);
            if (true === can) {
                this.driver().lock();
            } else {
                return this.lock(action);
            }
            return this;
        };

        this.unlock = function (action) {
            console.log("unlock " + action);
            this.driver().unlock();
            return this;
        };

        this.driver = function () {
            return new DBM(this.ns);
        };

        this.ake = function (obj, key, defaultValue) {
            if (typeof(defaultValue) === 'undefined') defaultValue = null;
            return typeof(obj[key]) === 'undefined' ? defaultValue : obj[key];
        };

        this.hash = function (obj) {
            var str = JSON.stringify(obj);
            shasum.update(str + this.entity);
            return shasum.digest('hex');
        };

        this.hashStr = function (str) {
            shasum.update(str);
            return shasum.digest('hex');
        };
    };

    module.exports = Mongood;
